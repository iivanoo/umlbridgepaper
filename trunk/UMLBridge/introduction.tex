\section{Introduction}\label{sec:intro}

Domain specific applications require notations enabling to capture specificities of the domain at the right level of abstraction. Domain Specific Languages (DSLs~\cite{FowlerBook}) have been introduced for this purpose, facilitating the specification of domain information. In Model Driven Engineering (MDE), UML profiling~\cite{UML} and Domain Specific Modeling~\cite{DSML} are the most used techniques for defining a DSL.

The \textit{UML profiling} technique consists in extending the UML modeling language with concepts coming from
the domain of interest \cite{UML}.
%\cite{UMLprofile}.
A UML profile is the definition of such an extension; the application of a profile to a UML model allows to tailor it with domain-specific information, by specializing existing UML meta classes. Among the most popular UML profiles, we can cite SysML \cite{sysml}
for modeling systems engineering applications, and MARTE \cite{marte} for real-time and embedded applications.
%and
%EAST-ADL\footnote{EAST-ADL specification site: %\small{\url{http://www.atesst.org}}} for automotive %electronic systems.

The \textit{Domain Specific Modeling} technique consists in defining and using languages dedicated to a specific domain.
Those languages are called Domain Specific Modeling Languages (DSMLs) and their concepts are usually formalized  via MOF metamodels~\cite{MOF}.
Each language can have its textual or graphical representation, and tool support can be provided either by generic (meta-modelling tools) or
ad-hoc modeling environments~\cite{DSML}.
Examples of DSML are AADL to model embedded real-time systems~\footnote{SAE AADL website: \small{\url{http://www.aadl.info}}}, 
%Backbone for component-based applications~\footnote{Backbone website: \small{\url{http://www.intrinsarc.com}}}, 
and BPMN for business processes~\footnote{BPMN information website: \small{\url{http://www.bpmn.org/}}}.

Currently, in many MDE projects both UML profiles and DSMLs are extensively used and each technique has its own strengths and weaknesses.
%depending on the needs of the various stakeholders.
The choice of the right approach depends on several aspects, such as tool support, language expressiveness,
models complexity, and company policies~\cite{comparison}.
%In general, profiled UML models are very much used since they are intuitive for designers and model editors already exist, however they are intrinsically complex for model manipulation (e.g., transformation, analysis); conversely, DSML models are more concise and easy to be manipulated, but they require an initial effort in terms of designers training and model editors development.
%A detailed discussion on how the two techniques differ is provided in .
%Determining which is the best technique is not in the scope of this paper
%and there are many cases in which they are used together in order to complement each other \cite{AAA}.
What can be noticed today is that UML profiles became extremely popular, and used as an extensive tool for describing domain specific
applications.
However, while of more immediate use for practitioners (since a profiled model is essentially an annotated UML model that can be
created using existing UML tools), developing a tool to manipulate profiled UML models is a complex activity; this is a consequence
of the inherent complexity of the involved models~\cite{comparison}\cite{france}.
Such a complexity is mainly due to
(i) the intricacy of the UML language, where many strictly related concepts are scattered across its metamodel (the so called "metamuddle"\cite{france})
, and (ii) because the application of a profile imposes additional constraints in the way models are manipulated~\cite{UMLprofile}.
%For example, profiles and stereotypes can only be applied in a fixed order, tagged values are accessed through ad-hoc mechanisms, and so on.
It is important to note that the complexity of manipulating profiled UML models is not strictly related to
the system of interest, but relies on the profiling technique itself.
%so we can consider it as an accidental complexity.

Goal of this work is to support those kind of projects in which the system is modelled using UML profiles, and there is a strong need of automatic model manipulation (e.g., to perform some kind of analysis~\cite{UMLprofilesAnalysis}).
This paper proposes an \textbf{automatic bridge} between UML profiles and MOF metamodels; such a bridge alleviates the accidental difficulty in manipulating profiled UML models, without forcing designers to abandon UML-based notations.
By using the bridge, on one side designers describe the system using UML profiles, and on the other side tools operate
on \textit{automatically generated} MOF-based models.
The bridge is totally transparent to designers since it operates at both metamodeling and modeling levels of abstraction.
%that is, designers can continue to develop models using UML profiles, and the bridge manages to transform them to MOF-based models.
At the metamodeling level, the bridge generates a MOF metamodel $MM_x$ representing the concepts of the UML profile.
At the modeling level, it transforms each UML model into a model conforming to $MM_x$, and vice versa.
%This unveils one of the advantages of our approach: designers interact with UML models and the tools manipulate only MOF-based models.
Since it is recurrent that designers use only a small subset of UML diagrams~\cite{france},
it is fundamental to generate a MOF metamodel containing only such elements, while discarding any other information; for this purpose, a \textbf{slicing mechanism} is presented. The proposed bridge is implemented as an Eclipse plugin and in this paper we apply it
%The Eclipse platform enables the integration of the bridge
%with other technologies available in the Eclipse community. 
%In this paper the proposed bridge 
on a case study based on OMG Systems Modeling Language (SysML). It is important to clarify that while this work might not provide some novel theoretical results, it provides a concrete solution to a problem that exists in practice.

The remainder of this paper is organized as follows. In Section~\ref{sec:motivation} we discuss the main motivations for our work.
We describe our automatic bridge in Section~\ref{sec:framework} and the mechanism for slicing the obtained MOF metamodel
in Section~\ref{sec:slicing}. Then, Section~\ref{sec:tool} gives some implementation details, and Section \ref{sec:caseStudy} describes the application of the bridge on a case study. Related work is discussed in Section~\ref{sec:related}. 
%and a discussion on how our bridge differs from other approaches are presented 
Finally, in Section~\ref{sec:conclusion} we discuss future work directions and draw the conclusions.
