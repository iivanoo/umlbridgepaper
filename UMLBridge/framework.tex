\section{The automatic bridge}\label{sec:framework}
\ivano{descrizione completa del bridge senza dettagli}
\ivano{3/4 di pagina per il running example?}
\marco{quale uso? }
\marco{da inserire immagini, e completare l'ultimo capoverso, quello che dipende dall'immagine. Per il resto, salvo altre considerazioni "SOLO" da revisionare}


The concept of bridge is used to denote the capability of interoperability between the UML approach and the DSL one. When a corresponding bridge is available for a metamodel and a corresponding profile, it is possible to produce automatically an UML profiled model from a model conforming to the metamodel in question and conversely. In our project we implement a bridge between the metamodels, either between models. The resulting artifacts of the bridge are: a metamodel which represents the profile we are about to translate,  automatically generated transformations which bridge a UML model conforming the profile in question and a model conforming to the brand new generated metamodel.

\marco{io ci metterei la figura che rappresenta schematicamente il bridge, quella che descrive quali sono gli input, qual e' il bridge ad alto livello e cosa restituisce. Se va bene la inserisco e chiudo questo paragrafo descrivendola come di seguito}
\marco{senza figura questa parte la cancello -->}

In the below figure,  source models are white, representing the input artifacts to be transformed, target models are red, to denote that they are automatically generated. The yellow shapes denote the bridge engine. As it can be noticed, the bridging procedure is split in two phases: the first one, the yellow ellipse in figure, works at the metamodeling level by generating a metamodel which is the representation of the profile (and the UML metamodel); the second phase, the yellow arrow in figure, works at the modeling level by automatically generating transformations from a UML model which has applied a profile to a model which is conform to the brand new generated metamodel.

\marco{<--senza figura questa parte la cancello}

The resulting metamodel can be considered a union of the UML metamodel (copied in the target one by means of an ad-hoc trasformation superomposed to our one) and the metamodel described in the profile model. We propose a further optimization to our tool which lets the developper to reduce the size of the UML metamodel imported in the target one.

\marco{metto due righe dicendo cosa si dira' nel seguito del paragrafo?}

In the following we will show the bridge behaviour at the metamodeling level and at the modeling one. In the end we will show the procedure we propose to slice the obtained metamodel.

\subsection{The bridge at the metamodeling level}\label{sec:metamodelLevel}
\ivano{livello meta con esempietto}

At the metamodeling level the bridge takes as input the UML metamodel and the profile. As shown in the previous figure 

\marco{nel primo paragrafo}

, it generates a metamodel by coping the UML metamodel in ECORE formalism, and by adding futher constructs which represent the elements in the profile. The figure 

\marco{inserire riferimento}

represents a UML profile translated into an EMF metamodel. All the UML metamodel elements are in the target metamodel, all the profiled elements (stereotypes and further data types) are represented in the target metamodel. The extension mechanism of a stereotype and its metaclass is represented by means of a binding mechanism. Every super class has a reference to the eventual stereotype.

\marco{immagine usata nella presentazione, quella della slide "Approccio finale" tra profilo e metamodello target}

In the figure 

\marco{inserire riferimento}

we show the behaviour of our approach. We have a stereotype \emph{MyStereotype2} which extends two metaclasses. By means of the superimposed  transformation we copy the UML metamodel, and we enrich it by adding extension attributes to every metaclasses which has been extended in the profile. The bridge, instead, creates a brand new element bounded with a composition relationship with the metaclasses it extends. In this scenario we have \emph{MyStereotype1} linked to the \emph{Class} metaclass and \emph{MyStereotype2} linked both to \emph{Class} and to \emph{Port}. As you can see in the fgure the classes of the UML metamodel are extended in the target metamodel since they own their attributes plus an extension extra-attribute which binds them to each stereotype.

\subsection{The bridge at the modeling level}\label{sec:modeLevel}

\ivano{livello modello con esempietto}

At the modeling level the bridge automatically generates transformations which bridge a profiled model in a model conforming to the brand new generated metamodel.

\marco{immagine usata nella presentazione, quella della slide "Generazione di regole di trasformazione", che mostra il codice generato nelle tre fasi. La posso modificare rendendola un'immagine unica e colorando le 3 fasi di generazione}

As shown in the above figure, the transformation generates a transformation at the modeling level in three phases: in the first one we generate rules to transofrm UML metaclasses into EMF ones; in the second phase we generate new rules to transform stereotype's applications into metaclasses' instances representing the stereotype in the target metamodel; in the last phase we generate imperative code, inserted at the end of every rules generated in the fist phase, to trigger the rules obtained in the second phase. The result is a transformation able to bridge a profiled model in a model conforming to the corresponding brand new genarated metamodel.

\marco{immagine usata nella presentazione, quella della slide "Applicazione sul caso di studio", tra modello profilato e modello target / oppure quella utilizzata nella tesi, capitolo 5.1.1 (ovviamente la rifaccio usando magic draw)?}

By executing this brand new transformation we complete the bridge from UML profiling to EMF metamodeling. As example we use the same scenario of the previous paragraph - modeling level. The model element 
\marco{... bla bla bla}

\section{Slicing the obtained metamodel}\label{sec:slicing}

As previously said, the default behavior of the bridge is to consider the whole UML metamodel and keep its metaclasses also in the
target MOF metamodel. If on one side this ensures that the bridge is loss-less with respect to the UML information we are...
(that is our primary goal while designing this system),
on the other side it moves the UML meta-muddle into the target MOF metamodel. 
In order to avoid this situation, we couple the bridge with a generic \textbf{slicing algorithm} that allows designers keep  
in the MOF metamodel only the subset of UML which is relevant for them.
At this point it is important to define what "relevant" means for UML models developers.

RELEVANT = POSSIAMO ASSUMERE CHE A LIVELLO MODELLO, AVREMO ISTANZE DI SOLO LE CLASSI RELEVANT
nel caso dei UML profiles questo è moooolto tipico: MagicDraw permette di farlo, Papyrus pure?

INFORMAZIONI RELEVANT = INSIEME DI METACLASSI (CHE IMPLICITAMENTE FORMANO UN SUBSET DI UML CON LE LORO RELAZIONI) 

Therefore, we needed a different way to collect this extra information that was related to the source model but not included in it. Since this information or parameters had to be available for the ATL program and considering that we were in a MDE context, the best option was to use another model (and thus to define a new metamodel): an annotation model.

LE METACLASSI RELEVANT LE POSSIAMO DEDURRE IN DIVERSI MODI

COME AIUTARE IL DESIGNER A FORNIRCI QUESTO INSIEME DI METACLASSI? DIVERSI MODI

Lo slice lavora come un post processor degli artifact prodotti dal bridge, e quindi abbiamo che in effetti lo slice e il bridge sono indipendenti e lo possiamo "attivare/disattivare" come ci pare. Questo implica anche il fatto che lo sclicer deve operare anch'esso a tutti
e due i livelli di astrazione.

SLICE A LIVELLO META:

 then only the portion of
the left metamodel involved in some operator application will be
part of the composed metamodel. The same mechanism holds for
\textit{sliceRight}. The relevant portion of metamodel is computed
by executing a slicing procedure before calculating the union of the metaclasses in
\texttt{leftMM} and \texttt{rightMM}. This slicing procedure is based on a
slicing algorithm for UML models~\cite{UMLSlicer}. Let
$MM$ be a metamodel and let $SC$ be a subset of the elements in
$MM$; $slice$ is defined as follows:

\vspace{-.3cm}
$$slice(SC)=SC \cup \displaystyle\bigcup_{c \in
SC}{slice(neighbour(c))}$$
\vspace{-.2cm}

\noindent where $neighbour(c)$ is the set of all superclasses of
$c$, of all classes referred (both with association and
aggregation) by $c$, and of all types of attributes
in $c$. It is important to note that even though $slice$ is defined
as a set of classes, since each class contains also references
to other classes, the final result is a part of the metamodel $MM$
with both classes and their relationships.

A LIVELLO MODELLO, NON CE NE FREGA DEI MODELLI VERI E PROPRI (perchè abbiamo fatto l'assunzione), MA CE NE FREGA DI ADATTARE LE TRASFORMAZIONI


%This facility is useful while composing a large metamodel and just a part of it is relevant
%for composition.
\ivano{descrizione dello slicing dal punto di vista tecnico}