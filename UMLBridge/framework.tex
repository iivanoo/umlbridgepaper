\section{The automatic bridge}\label{sec:framework}
%
The concept of bridge is used to denote the capability of interoperability between the UML approach and the DSML one. When a bridge is available for a metamodel and a corresponding profile, it is possible to produce automatically an UML profiled model from a model conforming to the metamodel in question and conversely. In our project we implement a bridge between the metamodels, either between models. The resulting artifacts of the bridge are: a metamodel which represents the profile we are about to translate,  automatically generated transformations which bridge a UML model conforming the profile in question and a model conforming to the brand new generated metamodel.
%
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.75\textwidth]{figures/overall.png}
	\caption{High-level view of the proposed bridge}
	\label{fig:overall}
\end{figure}
%
In the figure \ref{fig:overall},  we have a profile and some profiled models, representing the input artifacts to be transformed, target models are in the right side of the figure, to denote that they are automatically generated. As it can be noticed, the bridging procedure is split in two phases: the first one, consists in the generation of a metamodel which is the representation of the profile; the second phase consists in automatically generation of transformations at the modeling level which bridge a profiled UML model into a model conform to the brand new generated metamodel.

\subsection{The bridge at the metamodeling level}\label{sec:metamodelLevel}
At the metamodeling level the bridge takes as input the UML metamodel and the profile. The behaviour of our bridge at the metamodeling level is shown in figure \ref{fig:overall}, for the sake of simplicity, from now on, the distinction between the M3, M2 and M1 level is omitted in the figure. The resulting metamodel can be considered an union of the UML metamodel (copied in the target one by means of an ad-hoc transformation superimposed to our one) and the metamodel described in the profile model. The \textit{profile2ecore} transformation binds every element of the UML metamodel and every element in the profile. An additional effort has been spent while mapping a profile into a MOF metamodel. In the table the main feature are shown.
\begin{itemize}
	\item[$\bullet$] \textbf{Stereotype}, each stereotype is mapped into a MOF \textbf{Class}. For each tagged value a reference to the corresponding class is provided. Each MOF class is bounded to its own extended metaclass through a reference which name is \textit{base\_} + \textit{extendedMetaclass} and by means of a \textit{composition} association
	\item[$\bullet$] \textbf{Class}, each Class is mapped into a MOF \textbf{Class}. Each tagged which has been extended in the profile has a reference to the corresponding stereotype named  \textit{extension\_} + \textit{stereotypeName}
	\item[$\bullet$] \textbf{Profile}, each profile is mapped into a MOF \textbf{Package}
	\item[$\bullet$] \textbf{Property}, each property of a class (either a profile) is mapped into MOF \textbf{Attribute} or \textbf{Reference} depending on their type, simple data type or class
	\item[$\bullet$] \textbf{DataType} and \textbf{Enumeration}, each data type of a class (either a profile) is mapped into MOF \textbf{DataType} and MOF \textbf{Emumeration}
\end{itemize}
%
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{figures/metamodelingLevel.png}
	\caption{The bridge at the metamodeling level}
	\label{fig:metamodelingLevel}
\end{figure}
%
Figure \ref{fig:metamodelingExample} represents a trivial UML profile translated into a MOF metamodel. The Profile has been translated into a MOF package, the Component metaclass has been copied to the target metamodel and extended through the \textit{extension\_MyStereotype} attribute. Eventually the Stereotype has been translated into a MOF metaclass and bound with the extended metaclass by means of the composition reference.
%
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{figures/metamodelingExample.jpg}
	\caption{Transformation at the metamodeling level}
	\label{fig:metamodelingExample}
\end{figure}
%
\subsection{The bridge at the modeling level}\label{sec:modeLevel}

At the modeling level the bridge automatically generates transformations which bridge a profiled model in a model conforming to the brand new generated metamodel.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{figures/modelingLevel.png}
	\caption{The bridge at the modeling level}
	\label{fig:modelingLevel}
\end{figure}

As shown in figure \ref{fig:modelingLevel}, we use higher-order transformations to automatically generate transformations at the modeling level. The $uml2MM_xG"enerator$, and conversely the $MMX2umlGenerator$, generates a transformations in three phases: (i) in the first one we generate rules to transform UML metaclasses into MOF ones; (ii) in the second phase we generate new rules to transform stereotype' applications into metaclasses' instances representing the stereotype in the target metamodel; (iii) in the last phase we generate imperative code, inserted at the end of every rules generated in the fist phase, to trigger the rules obtained in the second phase. The result is a transformation able to bridge a profiled model in a model conforming to the corresponding brand new generated metamodel.

In the figure \ref{fig:modelingExample} we show the result of the execution of the generated transformation on a model which has applied a the example profile of figure \ref{fig:metamodelingExample}. As you can see the element is a \textit{Component} and has applied \textit{MyStereotype} stereotype. In the target model we have an instance of a \textit{Component} MOF class which has an instance of a \textit{MyStereotype} class. Every tagged value has been kept and rightly instantiated.
%
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{figures/modelingExample.jpg}
	\caption{Transformations at the modeling level}
	\label{fig:modelingExample}
\end{figure}
%

\section{Slicing the obtained metamodel}\label{sec:slicing}

As previously said, the default behavior of the bridge is to consider the whole UML metamodel and to keep its concepts also in the
target MOF metamodel. On one side this behavior ensures that our bridge is loss-less with respect to the information
provided in the models (it is our primary goal while designing the bridge);
however, on the other side it moves the complexity of the UML metamodel (it contains 246 classes and 583 properties)
into the target MOF metamodel. 
In order to avoid this situation, we couple the bridge with a generic \textbf{slicing mechanism} that allows it to consider  
only the \textit{subset of relevant UML concepts} when passing to the target MOF metamodel.

The subset of relevant UML concepts can be considered as the set of UML metaclasses that can be instantiated in the context of a specific project;
metaclasses outside the relevant set are never instantiated in any model.
A typical example is when designers assume that in the context of a specific project only UML
use case diagrams will be produced; the subset of relevant UML concepts contains only metaclasses 
the can be used in sequence diagrams (e.g., actor, use case, association) and there is no need to keep modeling concepts
for state machines, sequence diagrams, and so on.
This kind of assumptions is recurrent in practice, thus we designed our approach so that the target MOF metamodel contains only 
metaclasses corresponding to relevant UML concepts.
%indeed many UML modeling tools allow to restrict the kind of diagrams that can be created by designers. 

The set of relevant metaclasses is an information related to the target MOF metamodel but it is not included in it (it depends on specific needs of designers). 
Since the slicing mechanism is realized as a model transformation and considering that we were in a MDE context, the set of relevant
metaclasses is represented as an \textit{annotation model}
\footnote{An annotation model is a model containing auxiliary information about another model (the annotated model)\cite{MCDFthesis}} linked to the target MOF metamodel. The annotation model contains a link to each relevant metaclass coming from UML, the slicing mechanism uses those links to identify the metaclasses that will not be sliced out by the slicing procedure.

The current prototype of our approach provides three mechanisms to (semi) automatically obtain the annotation model that will drive the slicing procedure:

\begin{enumerate}
	\item the annotation model is automatically generated from a UML profile;
	\item designers specify only the types of UML diagram they will use, and the corresponding annotation model is automatically generated;
	\item designers provide a set of example UML models, and then the annotation model is automatically generated starting from them.
\end{enumerate}

The mechanisms are implemented as model-to-model transformations (see Section \ref{sec:tool} for more details);
each mechanism has a different level of automation and requires different input artifacts.
For example, if designers already know they will use only specific kinds of UML diagram, then option 2 seems to be the most convenient;
or else, if designers already defined some initial model, they may use the option 3.
Of course, if full control over the generated MOF metamodel is needed, designers can define the annotation model manually, that is they can create an annotation link for each metaclasses that can be instantiated in their UML models.

Once an annotation model is available, then the slicing mechanism can be performed;
it is based on a generic slicing algorithm for MOF metamodels~\cite{ICSEbyadl}. Let
$MM$ be a metamodel and let $SC$ be a subset of the elements in
$MM$; $slice$ is defined as follows:

\vspace{-.2cm}
$$slice(SC)=SC \cup \displaystyle\bigcup_{c \in
SC}{slice(neighbour(c))}$$
\vspace{-.2cm}

\noindent where $neighbour(c)$ is the set of all superclasses of
$c$, of all classes referred (both with association and
aggregation) by $c$, and of all types of attributes in $c$. 
It is important to note that even though $slice$ is defined
as a set of classes, since each class contains also references
to other classes, the final result is a subset of the metamodel $MM$
with both classes and their relations.
%
\begin{figure}
  \centering
  \subfloat[]{\label{fig:slicerMM}\includegraphics[scale=0.4]{figures/slicerMM}}      
 \hspace{10mm}          
  \subfloat[]{\label{fig:slicerT}\includegraphics[scale=0.4]{figures/slicerT.png}}
  \caption{Slicing the MOF metamodel (a) and the generated transformations (b)}
  \label{fig:animals}
\end{figure}
%
As can be seen in Figure \ref{fig:slicerMM}, the slicing algorithm is realized as a model-to-model transformation called \textit{MMslicer}.
It that takes as input a MOF metamodel $MM_x$ and an annotation model $am_x$, and generates a new metamodel $MM_sliced$ containing 
a subset of $MM_x$ according to the metaclasses referenced in $am_x$.

At this point we must consider a possible issue that may arise: once the target MOF metamodel has been sliced, the
previously generated model transformations of the bridge may refer to missing metaclasses in the metamodel.
This implies that our approach must provide a mechanism for adapting also the $UML2MM_x$ and $MM_x2UML$ transformations
to the newly sliced metamodel.
We are aware that in literature there are generic approaches managing the coupled evolution of metamodels and model transformations
\cite{TransEvolution}; however, since in our case we can assume that elements
can be only deleted from metamodels (we do not need to manage neither additions or updates), and since we need a fully automatic mechanism, we developed our minimalistic solution to automatically adapt model transformations to sliced metamodels.
Our solution takes inspiration from the EMFMigrate project\footnote{EMFMigrate project website: \small{\url{http://www.emfmigrate.org}}}
and it is based on an higher-order transformation; in this work we call it $Tslicer$.
%This kind of issue is well-known in the metamodel co-evolution research field \cite{CITAZIONI}, \footnote{http://www.emfmigrate.org}

Figure \ref{fig:slicerT} gives an idea of how the \textit{Tslicer} transformation works. It takes as input (i) the sliced metamodel
($MM_sliced$ in figure) and (ii) the model transformation to be adapted ($UML2MM_x$ in figure). $Tslicer$ automatically adapts the input transformation according to the meta-elements (i.e., metaclasses, attributes, references) 
that were previously sliced out from $MM_sliced$. The grey elements in Figure \ref{fig:slicerT} show that $Tslicer$ can also be
applied on the transformation in the other direction (i.e., $MM_x2UML$); this ensures that using the slicing mechanism does not affect
the bridge in terms of automation and bidirectionality. More details on $Tslicer$ are provided in Section \ref{sec:tool}.

In conclusion, it is important to note that the whole slicing mechanism (both on metamodels and transformations) 
acts as a post-processing activity of the artifacts generated by the bridge described in Section \ref{sec:framework}; this means that, according to project-specific needs, the proposed bridge and slicing mechanism can be used independently.
%Intuitively, it copies all the elements of the input transformation (like transformation rules, imperative statements, conditions, and so on)
%and ignores those elements that reference a meta-element  that are not in $MM_sliced$ anymore.

%removes those elements of the input model transformation (e.g., transformation rules, imperative statements, conditions)
%that reference a meta-element that is not in $MM_sliced$ anymore (i.e., such an element has been sliced out by $Mslicer$).  

